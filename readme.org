* hiolib - IO Library for Hy

** Overview

This library provides tools for writing sync/async IO functionality,
including three modules:

- hiolib.rule :: macros that help write both sync/async code
  simultaneously
- hiolib.stream :: layered sync/async stream abstraction and basic
  stream implementation including bytes, file and network
- hiolib.struct :: macros that define structures (sync/async
  pack/unpack functions) declaratively in DSL


** hiolib.rule

Example:

#+begin_src hy
  (async-deffunc foo-bar-func []
    (async-if 'async 'async))

  ;;; expand to =>
  (defn   foo-bar-func       [] 'sync)
  (defn/a async-foo-bar-func [] 'async)
#+end_src

#+begin_src hy
  (async-defclass FooBarBase []
    (async-defn meth [self]
      (async-wait ((async-name foo-bar-func)))))

  (async-defclass FooBar [(async-name FooBar)]
    (async-defn meth [self]
      (async-wait (#super meth))))

  ;;; expand to =>
  (defclass FooBarBase      []                (defn   meth [self] (foo-bar-func)))
  (defclass AsyncFooBarBase []                (defn/a meth [self] (await (async-foo-bar-func))))
  (defclass FooBar          [FooBarBase]      (defn   meth [self] ((. (super) meth))))
  (defclass AsyncFooBar     [AsyncFooBarBase] (defn/a meth [self] (await ((. (super) meth)))))
#+end_src

Note that macros =async-deffunc= and =async-defclass= expand their
bodies twice in sync/async env; Macro =async-if= expands to form based
on env, eg. (=async-if= =asyncio.sleep= =time.sleep=) expands to
=asyncio.sleep= in async env and =time.sleep= in sync env;
=async-name= and =async-deffunc/async-defclass= expand name based on
env, such as =foo-bar/async-foo-bar= and
=FooBar/AsyncFooBar=. (=async-name= =NAME=) is just a wrapper of
(=async-if= =ASYNC-NAME= =NAME=); Some function/special forms are also
wrapped, such as =async-defn= to =defn(/a)?=, =async-wait= to
=(await)?=, =async-next= to =a?next=.

** hiolib.stream

=Async?Stream= similar to Golang's =ReadWriteCloser=, which can be
read, write and closed.

Example:

#+begin_src hy
  (async-defclass Requester []
    (defn #-- init [self host [port 80]]
      (setv self.host host self.port port))

    (defn request [self]
      (async-with [stream (async-wait (.open-connection (async-name TCPStream) self.host self.port))]
        (async-wait (.write stream (.encode f"GET / HTTP/1.1\r\nHost: {self.host}\r\n\r\n")))
        (async-wait (.read stream)))))
#+end_src

Note that class method =Async?TCPStream.open-connection= can create a
basic tcp stream, other ways to create basic streams are also
provided: =Async?TLSStream.open-connection=, =RawIOStream=, and
=BIOStream= which is a wrapper of =RawIOStream= and =BytesIO=.

=Async?Stream= is layered, and layered stream can be created by
=Async?Connector/Acceptor= that are also
layered. [[https:github.com/vhqr0/hproxy][hproxy]] provides some
stream protocol implementations, such as websocket, tls13, and vmess.

Example:

#+begin_src hy
  (async-defn request [self]
    (async-with [lowest-stream (async-wait (.open-connection TLSStream self.node-host self.node-port self.tls-ctx self.tls-host))]
      (let [connector ((async-name TLS13Stream)
                        :host self.host
                        :next-layer ((async-name VMessConnector)
                                      :id self.id
                                      :host self.host
                                      :port self.port
                                      :next-layer ((async-name WSConnector))))
            stream (async-wait (.connect-with-head connector
                                 :lowest-stream lowest-stream
                                 :head (.encode f"GET / HTTP/1.1\r\nHost: {self.host}\r\n\r\n")))])
      (async-wait (.read stream))))
#+end_src

In the example, an https-over-vmess-over-wss =stream= was created,
with a layer of =TLS13Stream/VMessStream/WSStream/TLSStream=, where
=TLSStream= is the system TLS stream, and =TLS13Stream= is the pure
Python TLS stream; =connector= is also layered, with a layer of
=TLS13Connector/VMessConnector/WSConnector=.

** hiolib.struct

Example:

#+begin_src hy
  (defstruct IPv6Addr
    [[bytes addr
      :len 16
      :from (socket.inet-pton socket.AF-INET6 it)
      :to (socket.inet-ntop socket.AF-INET6 it)]])

  (defstruct IPv6
    [[bits [ver tc fl] :lens [4 8 20]]
     [int plen :len 2]
     [int nh :len 1]
     [int hlim :len 1]
     [struct [[src] [dst]] :struct (async-name IPv6Addr) :repeat 2]])

  (IPv6.pack :ver 6 :tc 0 :fl 0 :plen 80 :nh 13 :hlim 64 :src "2000::1" :dst "240c::6666")
  ;;; => b"`\x00\x00\x00\x00P\r@ \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01$\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00ff"

  (IPv6.unpack b"`\x00\x00\x00\x00P\r@ \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01$\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00ff")
  ;;; => (6, 0, 0, 80, 13, 64, '2000::1', '240c::6666')
#+end_src

Macro =defstruct= expands the DSL describing structure into
corresponding pack/unpack functions. More precisely, defining
subclasses of =Async?Struct= and implementing class methods
=pack-to-stream/unpack-from-stream=.

In DSL, the 1st param is type, within =all=, =bytes=, =int=, =varlen=,
=line=, =bits= and =struct=; the 2nd param is destruct names,
eg. =ver:4=, =tc:0=, =fl:0= are grouped as
=group-ver-tc-fl:(ver,tc,fl):(4,0,0)= during packing, and as
=(ver,tc,fl):group-ver-tc-fl:(4,0,0)= during unpacking; the rest k-v
params are processed by corresponding types, usually a form embedded
in the generated code.

* hproxy - 基于 hiolib 的简单代理工具

** Overview

- hproxy.proto :: 流协议的连接器/接收器/请求器的集合，包括 DNS、HTTP、
  WebSocket、TLS1.3、Socks5、Tronjan、VMess
- hproxy.iob :: 代理出入口的可序列化配置对象实现，包括 Block、Direct、
  HTTP、Socks5、Trojan 和 VMess
- hproxy.cli :: 代理工具集，包括配置管理、运行代理服务、通过代理进行
  HTTP/DNS 请求、同步订阅链接等

** hproxy.proto

=hproxy.proto= 实现了 =hiolib.stream= 中多种流协议的
=Async?Connector/Acceptor= ，特别的，对于代理协议的连接器、接收器都继
承自子类 =Async?ProxyConnector/Acceptor= ，其中连接器有固定的参数
=host= 和 =port= ，表示代理的目的主机和端口；接收器在接收一个流后其
=host= 和 =port= 属性被设置为代理请求的目的主机和端口。请求器
=Async?Requester= 用于在流上进行一次请求，例如 HTTP 请求或 DNS 查询。

例子：

#+begin_src hy
  (let [requester (HTTPRequester :meth "GET" :path "/" :host "www.google.com")
        vmess-connector (VMessConnector :id vmess-id :host "www.google.com" :port 443)
        connector (TLS13Connector :host "www.google.com" :next-layer vmess-connector)]
    (with [lowest-stream (TCPStream.open-connection vmess-node-host vmess-node-port)]
      (let [stream (.connect-with-head connector lowest-stream requester.head)]
        (.request requester stream))))
#+end_src

=hproxy.proto= 中提供的连接器/接受器/请求器：

- DNS :: =hproxy.proto.dns.DNSRequester=
- HTTP :: =hproxy.proto.http.HTTPConenctor= =hproxy.proto.http.HTTPAcceptor= =hproxy.proto.http.HTTPRequester=
- WebSocket :: =hproxy.proto.ws.WSConnector= =hproxy.proto.ws.WSAcceptor=
- TLS1.3 :: =hproxy.proto.tls13.TLS13Connector= # 纯 Python 实现，只有连接器
- Socks5 :: =hproxy.proto.socks5.Socks5Connector= =hproxy.proto.socks5.Socks5Acceptor= =hproxy.proto.socks5.AutoAcceptor= # 自动识别 Socks5/HTTP 代理请求
- Trojan :: =hproxy.proto.socks5.TrojanConnector= =hproxy.proto.socks5.TrojanAcceptor= # 在 =hproxy.proto.socks5= 中
- VMess :: =hproxy.proto.vmess.VMessConnector= # 只有连接器


=hproxy.proto= 还提供了这些类的响应的工具，例如 =hproxy.proto.socks5.get-trojan-auth= 、 =hproxy.proto.vmess.VMessID= 等。

** hproxy.iob

=hproxy.iob= 实现了代理出口、入口的可序列配置对象 =Async?OUB/INB= 。这
些对象可以被序列化、打开代理底层的 TCP/TLS/WS/WSS 流、根据 =scheme= 和
可选的 =extra= 字段重复生成对应的不可复用的代理连接器/接收器对象。

例子：

#+begin_src hy
  ;;; 本地 1080 端口开启的自动识别 Socks5/HTTP 的代理入口
  (INB.from-conf
    (INBConf.model-validate
      {"scheme"   "auto"
       "host"     "localhost"
       "port"     1080
       "tls"      None
       "ws"       None
       "extra"    None}))

  ;;; 10811 端口的 vmess-over-wss 代理出口
  (OUB.from-conf
    (OUBConf.model-validate
      {"managed"   False
       "enabled"   True
       "name"      "forward"
       "group"     "forward"
       "dnsname"   "your.vmess.server.local"
       "delay"     0.0
       "scheme"    "vmess"
       "host"      "your.vmess.server.local"
       "port"      10811
       "tls"       {"host" "your.vmess.server.local" "cafile" None}
       "ws"        {"host" "your.vmess.server.local" "path" "/"}
       "extra"     {"id" "you-vmess-id"}}))

  ;;; 特殊 scheme，丢弃所有请求
  (OUB.from-conf
    (OUBConf.model-validate
      {"managed"   False
       "enabled"   True
       "name"      "block"
       "group"     "block"
       "dnsname"   ""
       "delay"     0.0
       "scheme"    "block"
       "host"      ""
       "port"      0
       "tls"       None
       "ws"        None
       "extra"     None}))

  ;;; 特殊 scheme，直接执行请求连接目的主机端口
  (OUB.from-conf
    (OUBConf.model-validate
      {"managed"   False
       "enabled"   True
       "name"      "direct"
       "group"     "direct"
       "dnsname"   ""
       "delay"     0.0
       "scheme"    "direct"
       "host"      ""
       "port"      0
       "tls"       None
       "ws"        None
       "extra"     None}))
#+end_src

=hproxy.proto= 中提供的代理出口/入口 =scheme= 包括 =block= =direct=
=auto= =http= =socks5= =trojan= =vmess= ，其中 =auto= 仅入口， =block=
=direct= =vmess= 仅出口。

通过代理配置发起请求的例子：

#+begin_src hy
  (let [requester (HTTPRequester :meth "GET" :path "/" :host "www.google.com")
        highest-connector (if https? (TLS13Connector :host "www.google.com") None)]
    (with [stream (.connect oub "www.google.com" (if https? 443 80) requester.head highest-connector)]
      (.request requester stream)))
#+end_src

** hproxy.cli

*** scripts

#+begin_src sh
  PYTHONPATH=. hy scripts/confgen.hy > config.yaml # 生成配置文件模板

  # 可选的，从社区维护的代理规则集中生成 tags，复制到配置中
  git clone https://github.com/v2fly/domain-list-community
  hy scripts/tagsgen.hy > tags.yaml
#+end_src

*** hproxy.cli.ls

#+begin_src sh
  hy -m hproxy ls                 # 列出所有使用的出口
  hy -m hproxy ls -a              # 列出所有出口
#+end_src

*** hproxy.cli.run

#+begin_src sh
  hy -m hproxy run                # 运行代理服务
#+end_src

*** hproxy.cli.curl

#+begin_src sh
  hy -m hproxy curl http://www.google.com # 请求并输出 Google 的 HTTP 主页
  hy -m hproxy curl -v direct -o google.html https://www.google.com # 通过 direct 组代理出口请求并保存 Google 的 HTTPS 主页

  # curl 风格的参数，添加到 url 之后
  hy -m hproxy curl https://www.google.com -X POST -H "Content-Type: application/json" -H "Content-Length: 10"

  hy -m hproxy curl dns://8.8.8.8 www.google.com # dns 查询
  hy -m hproxy curl dot://8.8.8.8 -t AAAA www.google.com # dot IPv6 查询
#+end_src

*** hproxy.cli.dig

#+begin_src sh
  hy -m hproxy dig
  hy -m hproxy dig -v direct -t forward dns://8.8.8.8 -c AAAA
#+end_src

利用 =hproxy.cli.curl= 解析代理出口组所有出口的域名，出口的域名将被附
加在最后构成一个 curl 命令。

*** hproxy.cli.ping

#+begin_src sh
  hy -m hproxy ping
  hy -m hproxy -t forward ping http://www.google.com
  hy -m hproxy -t forward ping https://www.google.com -X POST
#+end_src

利用 =hproxy.cli.curl= 测试代理出口组所有出口的可用性和延迟。

*** hproxy.cli.fetch

#+begin_src sh
  hy -m hproxy fetch
#+end_src

从代理出口组的所有 V2rayN 格式的订阅链接中获取代理出口。订阅链接存储在
配置文件的 =extra.fetchers= 中。

** TODOS

*** TODO document it

完善文档，翻译成英文。

*** TODO hproxy.proto.tls13 证书验证

目前 curl、dig、ping 使用的自带的 TLS 实现没有验证证书。

基于
[[https:/cryptography.io/en/latest/x509/verification/][cyrptography.x509.verification(WIP)]]
实现证书验证。

*** TODO hproxy.cli.dig 调试

因未知原因 dig 即使设置了很大的超时时间也总是超时，而 curl 可以正常进
行域名解析。

*** TODO hproxy.proto.vmess 实现接收器

vmess-aead 比 vmess-legacy 更好实现，主要问题在于如何全局管理 eaid，或
者不检查重方攻击。

*** TODO hproxy.proto.tls13 完善

=hproxy.proto.tls13= 最大的问题是前面的证书验证问题，还有一些小问题，
包括实现 PSK 机制、处理密钥更新请求等。考虑实现服务端。

*** TODO hproxy.proto.ss 实现

考虑实现 Shadow Socks 协议，为 =hproxy.cli.fetch= 添加 ss 支持。主要问
题是缺乏文档，包括 ss 协议和 V2rayN 格式协议。
